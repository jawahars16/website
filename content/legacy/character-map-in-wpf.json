{"meta":{"published_date":"2012-06-04T00:00:00.000Z","postId":"character-map-in-wpf","title":"Character Map in WPF","excerpt":"\t\t\t\nIntroduction   \n(View this article in code project)\n\nThe Character Map utility is free on all Windows machines and can be used to copy and paste accented letters and other foreign language characters into any Windows application. The Character Map is similar to the Insert Symbol tool found in so","tags":[],"featuredImage":"http://www.codeproject.com/KB/WPF/396811/character_map.gif"},"content":"\n\t\t\t\t<div dir=\"ltr\"><p></p>\n<h2>Introduction&#xA0;<span>&#xA0;&#xA0;</span></h2>\n<div><span><a href=\"http://www.codeproject.com/Articles/396811/Character-Map-in-WPF\" target=\"_blank\">(View this article in code project)</a></span></div>\n<div></div>\n<div>The&#xA0;<strong>Character Map</strong>&#xA0;utility is free on all Windows machines and can be used to copy and paste accented letters and other foreign language characters into any Windows application. The&#xA0;<em>Character Map</em>&#xA0;is similar to the<em>&#xA0;Insert Symbol</em>&#xA0;tool found in some Windows applications such as&#xA0;<em>Microsoft Word</em>.</div>\n<div>This article explains how to implement this tool using WPF with great performance. This tool can be easily integrated into any of your WPF applications easily.&#xA0;&#xA0;</div>\n<div><img src=\"https://i1.wp.com/www.codeproject.com/KB/WPF/396811/character_map.gif\"></div>\n<h2>Using the code&#xA0;</h2>\n<div>When I was start thinking about implementing this in WPF, I realized the main challenge would be the performance. But the native character map in Windows is really faster and will give a nice user experience.&#xA0;So I am sure this article will be valid only if this tool would also give the same experience.&#xA0;</div>\n<h3><span>Getting the symbols&#xA0;&#xA0;</span></h3>\n<div>Let me first start with getting the symbols from Font files. Populating a&#xA0;<code>ComboBox&#xA0;</code>with installed Font families is not a big deal in WPF. The&#xA0;<a href=\"http://wpfplayground.blogspot.in/2012/05/bind-system-font-families-to-combo-box.html\" title=\"Bind Font Families to WPF Combo Box\">article</a>&#xA0;explains how to do that. Also the code is so simple.</div>\n<div id=\"premain0\"></div>\n<pre><code>&lt;ComboBox ItemsSource=&quot;{x:Static Fonts.SystemFontFamilies}&quot; /&gt;</code></pre>\n<div>To get the available symbols from a Typeface, first iterate through the typefaces in a Font family and choose the appropriate one. Once you got the Typeface, get the glyph which gives you the character map dictionary.&#xA0;</div>\n<div id=\"premain1\"></div>\n<pre><code>IDictionary&lt;int, ushort&gt; characterMap;<br>foreach (Typeface typeface in font.GetTypefaces())<br>{<br>   typeface.TryGetGlyphTypeface(out glyph);<br>   if (glyph != null)<br>   {<br>     characterMap = glyph.CharacterToGlyphMap;<br>   }<br>}</code></pre>\n<div>The&#xA0;variable&#xA0;<code>characterMap&#xA0;</code>is a dictionary, which stores the unicode values for our symbols. So now we can go ahead and display the symbols in UI.</div>\n<h3><span>Symbols UI&#xA0;&#xA0;</span></h3>\n<div>As I previously stated, the performance will be a major bottle neck in WPF. Since some font families may have more than 20,000 symbols. In case if you like to show them in a traditional ListBox with a wrap panel you would lose the user experience which Windows default character map has. I am sure there is a Virtualization Wrap Panel for WPF posted in this code project&#xA0;<a href=\"http://www.codeproject.com/Articles/75847/Virtualizing-WrapPanel\" title=\"Virtualizing Wrap Panel\">article</a>.&#xA0;But I am going to use something better in which we don&#x2019;t need to care about the containers generation and disposing them.</div>\n<div>I am going to use a Canvas and I decided my viewport size would be 345 X 250 and not more than that. Based on this I have placed 150&#xA0;<code>SymbolView</code>&#xA0;(view that holds the symbol)&#xA0;objects into the canvas in horizontal wrap manner. Each view will have a textbox displaying the corresponding text of the symbol unicode.</div>\n<div id=\"premain2\"></div>\n<pre><code>&lt;Border x:Class=&quot;CharacterMap.SymbolView&quot;<br>         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;<br>         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;<br>         xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; <br>         xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; <br>         RenderTransformOrigin=&quot;0.5, 0.5&quot;<br>         mc:Ignorable=&quot;d&quot; Width=&quot;23&quot; <br>         Height=&quot;25&quot; Background=&quot;White&quot;<br>         d:DesignHeight=&quot;300&quot; d:DesignWidth=&quot;300&quot; <br>         BorderBrush=&quot;Black&quot; BorderThickness=&quot;0 0 1 1&quot;&gt;<br>    &lt;TextBlock Text=&quot;&quot; x:Name=&quot;charcter&quot; FontSize=&quot;17&quot; <br>      VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;/&gt;<br>&lt;/Border&gt;</code></pre>\n<div>So now, everytime the user choose the Font family in the Combo Box, I will update the 150 tiles with corresponding symbols. I am using a Dispatcher timer to ensure the things will not kill the UI thread.&#xA0;</div>\n<div id=\"premain3\"></div>\n<pre><code>private void Repaint(double value)<br>{<br>    i = Convert.ToInt32((value / 0.1) * 15);<br>    item_index = 0;<br>    timer.Start();<br>} </code></pre>\n<div>In the tick event of the timer, I am updating the tiles,</div>\n<div id=\"premain4\"></div>\n<pre><code>void timer_Tick(object sender, EventArgs e)<br>{<br>     try<br>     {<br>         SymbolView view = canvas.Children[item_index] as SymbolView;<br>         int index = characterMap.Keys.ElementAt(i);<br>         char c = Convert.ToChar(index);<br>         view.charcter.Text = c.ToString();<br>         item_index++;<br>         i++;<br>     }<br>     catch (Exception)<br>     {<br>         SymbolView view = canvas.Children[item_index] as SymbolView;<br>         view.charcter.Text = &quot;&quot;;<br>         item_index++;<br>         i++;<br>     }<br>     if (item_index &gt;= 150)<br>     {<br>         timer.Stop();<br>         item_index = 0;<br>     }<br>}</code></pre>\n<h3><span>Scrolling&#xA0;</span><span>&#xA0;</span></h3>\n<div>Now its time to handle the Scroll bar. Since I am not using the WPF Items Control, the scrollbars will not work for my case. And it is clear that we will be having only 150 tiles in the UI. So the idea is, we have a&#xA0;<code>ScrollBar</code>&#xA0;near to the canvas showing symbols. Based on the scroll offset, the entire tiles are repainted with updated symbols. The work, is we should match the scrollbar offset to the current symbols in the view.&#xA0;&#xA0;</div>\n<div>The base idea is, even though we got 20,000 symbols for a Font Family, we are showing only 150 symbols. On scrolling we will update the symbols based on the offset. &#xA0;&#xA0;</div>\n<div id=\"premain5\"></div>\n<pre><code>private void OnScroll(object sender, ScrollEventArgs e)<br>{<br>   Repaint(e.NewValue);<br>}<br><br>private void Repaint(double value)<br>{<br>    i = Convert.ToInt32((value / 0.1) * 15);<br>    item_index = 0;<br>    timer.Start();<br>}  </code></pre>\n<div>So now we got a nice scrolling effect even though we have huge number of symbols.&#xA0;Also I have added the Key Down behavior. You could also navigate through the symbols using the Keyboard. A textbox is also there to select and copy the symbols.&#xA0;</div>\n<div></div>\n<div><a href=\"http://www.codeproject.com/KB/WPF/396811/Demo.zip\" target=\"_blank\">Download Demo</a></div>\n<div></div>\n<div><a href=\"http://www.codeproject.com/KB/WPF/396811/CharacterMap.zip\" target=\"_blank\">Download Source</a></div>\n<div></div>\n</div>\n\t\t\t"}