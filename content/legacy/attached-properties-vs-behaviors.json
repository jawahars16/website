{"meta":{"title":"Attached Properties VSÂ Behaviors","excerpt":"\t\t\tOne of the powerful concept of WPF is Attached Properties. The primary purpose of attached property is to define a unique value to child elements for a property, which is defined in Parent element as MSDN suggests. Some of the typical examples are Grid.Row, DockPanel.Dock, etc.\nBut it can also be","tags":["attached properties","behavior","wpf","xaml"],"featuredImage":"https://s0.wp.com/i/blank.jpg","published_date":"2014-12-16T00:00:00.000Z","postId":"attached-properties-vs-behaviors"},"content":"\n\t\t\t\t<p>One of the powerful concept of WPF is Attached Properties. The primary purpose of attached property is to define a unique value to child elements for a property, which is defined in Parent element as <a href=\"http://msdn.microsoft.com/en-IN/library/ms749011(v=vs.110).aspx\">MSDN </a>suggests. Some of the typical examples are Grid.Row, DockPanel.Dock, etc.</p>\n<p>But it can also be used to attach additional information to an object, like Extension methods in C#. Examples are allowing an object to be draggable using Mouse, play music on some action, etc.&#xA0;I will take a simple piece of functionality to explain this. Lets consider, we need to <strong>focus a control on loaded</strong>.</p>\n<p><span id=\"more-588\"></span></p>\n<p><strong>Using Attached Property</strong></p>\n<pre><code>    public static class FocusOnLoad<br>    {<br>        public static bool GetCanFocusOnLoad(DependencyObject obj)<br>        {<br>            return (bool)obj.GetValue(CanFocusOnLoadProperty);<br>        }<br><br>        public static void SetCanFocusOnLoad(DependencyObject obj, bool value)<br>        {<br>            obj.SetValue(CanFocusOnLoadProperty, value);<br>        }<br><br>        // Using a DependencyProperty as the backing store for CanFocusOnLoad.  This enables animation, styling, binding, etc...<br>        public static readonly DependencyProperty CanFocusOnLoadProperty =<br>            DependencyProperty.RegisterAttached(&quot;CanFocusOnLoad&quot;, typeof(bool), typeof(FocusOnLoad), new PropertyMetadata(FocusOnLoadChanged));<br><br>        private static void FocusOnLoadChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)<br>        {<br>            var element = d as FrameworkElement;<br>            if (element != null)<br>            {<br>                element.Loaded += delegate<br>                {<br>                    element.Focus();<br>                };<br>            }<br>        }<br>    }<br></code></pre>\n<p><strong>Usage in XAML</strong></p>\n<pre><code>    &lt;TextBox behaviors:FocusOnLoad.CanFocusOnLoad=&quot;True&quot;<br>             VerticalAlignment=&quot;Center&quot;<br>             Width=&quot;200&quot;/&gt;<br></code></pre>\n<p>To make the work more systematic, Microsoft came up with an option called <a href=\"http://wpftutorial.net/Behaviors.html\">Behaviors</a>. It offers more encapsulated way to extend functionality. There are some <a href=\"http://msdn.microsoft.com/en-us/library/vstudio/dn195718(v=vs.110).aspx\">built-in behaviors</a>&#xA0;shipped as part of Blend. Following code implements the same functionality using Behaviors.</p>\n<p><strong>Using Behaviors</strong></p>\n<pre><code>    public class FocusOnLoadBehavior : Behavior&lt;FrameworkElement&gt;<br>    {<br>        protected override void OnAttached()<br>        {<br>            this.AssociatedObject.Loaded += this.OnLoaded;<br>        }<br><br>        protected override void OnDetaching()<br>        {<br>            this.AssociatedObject.Loaded -= this.OnLoaded;<br>        }<br><br>        private void OnLoaded(object sender, System.Windows.RoutedEventArgs e)<br>        {<br>            this.AssociatedObject.Focus();<br>        }<br>    }<br></code></pre>\n<p><strong>Usage in XAML</strong></p>\n<pre><code>    &lt;TextBox behaviors:FocusOnLoad.CanFocusOnLoad=&quot;True&quot;<br>                VerticalAlignment=&quot;Center&quot;<br>                Width=&quot;200&quot;&gt;<br>        &lt;i:Interaction.Behaviors&gt;<br>            &lt;behaviors:FocusOnLoadBehavior /&gt;<br>        &lt;/i:Interaction.Behaviors&gt;<br>    &lt;/TextBox&gt;<br></code></pre>\n<p>There are some advantages and dis-advantages in both approach. Let me put it down to make the decision easier.</p>\n<h1><strong>1. Event Handlers</strong></h1>\n<p>Both scenario need an event subscription to the Control.Loaded event. In attached properties it is an ugly code, where we need to write extra plumbing to release those handlers. But behaviors offer a clean way to release event handlers &#x2013; <strong><em>OnAttached and OnDetaching</em></strong>. If the functionality dealing with more event handling mechanisms, Behaviors are the best way.</p>\n<h1>2.&#xA0;Configuration in Style</h1>\n<p>For example, if you want to attach this piece of functionality to all the TextBoxes in your application, a global style would be the best option. But&#xA0;attached properties can be set in Style, where Behaviors cannot. This is also an important factor need to be considered before taking decision.</p>\n<pre><code>&lt;Style TargetType=&quot;TextBox&quot;&gt;<br>    &lt;Setter Property=&quot;behaviors:FocusOnLoad.CanFocusOnLoad&quot;<br>            Value=&quot;True&quot; /&gt;<br>&lt;/Style&gt;<br></code></pre>\n<p><strong>3. Casting</strong></p>\n<p>The <strong>PropertyChanged</strong> callback will give you the dependency object. This is the element in XAML, where we set the property. But to access some property or to invoke a method we need to <strong>cast</strong> it to UIElement or FrameworkElement. But in Behavior, it is possible to mention the datatype &#x2013;&#xA0;<strong>Behavior&lt;T&gt;</strong>. So no more casting.&#xA0;Using <strong>AssociateObject</strong> all the members of the type can be accessed. In above case, I mentioned it as <strong>FrameworkElement</strong>, since the Loaded event coming from that.</p>\n<h1>4. Visual Designer</h1>\n<p>Behaviors can be drag and drop into particular object using Blend, where Attached properties are not.You can drag and drop behavior objects on other behavior objects to set up a hierarchy, and you can set properties on objects already in the designer through the properties window.</p>\n<p>Hope this will&#xA0;shed some light on choosing a right option. &#x1F642;</p>\n\t\t\t"}