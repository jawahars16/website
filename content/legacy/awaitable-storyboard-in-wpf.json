{"meta":{"title":"Awaitable storyboard in WPF","excerpt":"\t\t\tNormally when a storyboard is running, setting the FillBehavior (Learn more about FillBehavior) to HoldEnd is risk. Because for a dependency property, storyboard is considered to have highest priority of setting the value. So once storyboard is done, user cannot change its value locally. So users","tags":["animation","async","asynchronous","await","storyboard","wpf","xaml"],"featuredImage":"https://s0.wp.com/i/blank.jpg","published_date":"2014-07-28T00:00:00.000Z","postId":"awaitable-storyboard-in-wpf"},"content":"\n\t\t\t\t<p>Normally when&#xA0;a storyboard is running, setting the FillBehavior (<a href=\"http://msdn.microsoft.com/en-us/library/system.windows.media.animation.timeline.fillbehavior(v=vs.110).aspx\" target=\"_blank\">Learn more about FillBehavior</a>) to <a href=\"http://msdn.microsoft.com/en-us/library/system.windows.media.animation.fillbehavior(v=vs.110).aspx\">HoldEnd </a>is risk. Because&#xA0;for a dependency property, storyboard is considered to have highest priority of setting the value. So once storyboard is done, user cannot change its value locally. So users prefer the set the FillBehavior to Stop and change the target value once storyboard is done. So there must be always a need to do something once animation is done. Fortunately, storyboard provided an event called <a href=\"http://msdn.microsoft.com/en-us/library/system.windows.media.animation.timeline.completed(v=vs.110).aspx\">Completed </a>where we can write our own logic.</p>\n<p>But once<a href=\"http://msdn.microsoft.com/en-in/library/hh191443.aspx\"> <em>async</em> and <em>await</em></a> released to get rid off these callback approach, why can&#x2019;t we make our storyboard an awaitable one. Let the storyboard Begin method wait until the animation completed, before it executed the next line.</p>\n<p><span id=\"more-404\"></span></p>\n<pre><code>        public static Task BeginAsync(this Storyboard timeline)<br>        {<br>            TaskCompletionSource&lt;object&gt; source = new TaskCompletionSource&lt;object&gt;();<br>            timeline.Completed += delegate<br>            {<br>                source.SetResult(null);<br>            };<br>            timeline.Begin();<br>            return source.Task;<br>        }<br></code></pre>\n<p>This is how we will be using it in our application,</p>\n<pre><code>        private async void MainWindow_Loaded(object sender, RoutedEventArgs e)<br>        {<br>            Storyboard animation = (Storyboard)this.Resources[&quot;HideAnimation&quot;];<br>            if (animation != null)<br>            {<br>                await animation.BeginAsync();<br>                MessageBox.Show(&quot;Animation completed&quot;);<br>            }<br>        }<br></code></pre>\n<p><strong>Note</strong> : It is always not recommended to use async void except UI event handlers.</p>\n\t\t\t"}