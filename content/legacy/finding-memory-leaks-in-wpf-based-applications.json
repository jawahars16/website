{"meta":{"featuredImage":"https://wpfplayground.files.wordpress.com/2011/10/ee4b5-14.jpg?w=300","published_date":"2011-10-01T00:00:00.000Z","postId":"finding-memory-leaks-in-wpf-based-applications","title":"Finding Memory Leaks in WPF-basedÂ applications","excerpt":"\t\t\t\n\n  \nThere are numbers of blogs that folks wrote about memory leaks in Microsoft .Net Framework managed code and unmanaged code based applications. \nThis blog,\n\nShow coding practices      that can cause memory leaks which are more unique to WPF-base apps \nShare information about      memory leaks","tags":[]},"content":"\n\t\t\t\t<div dir=\"ltr\">\n<div></div>\n<p><!--[if !mso]&gt; v\\:* {behavior:url(#default#VML);} o\\:* {behavior:url(#default#VML);} w\\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);}  &lt;![endif]--><!--[if gte mso 9]&gt;        &lt;![endif]--><!--[if gte mso 9]&gt;     Normal   0   false            false   false   false      EN-US   X-NONE   TA                                                                                             &lt;![endif]--><!--[if gte mso 9]&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                &lt;![endif]--><!--[if gte mso 10]&gt;  /* Style Definitions */  table.MsoNormalTable  {mso-style-name:\"Table Normal\";  mso-tstyle-rowband-size:0;  mso-tstyle-colband-size:0;  mso-style-noshow:yes;  mso-style-priority:99;  mso-style-parent:\"\";  mso-padding-alt:0in 5.4pt 0in 5.4pt;  mso-para-margin-top:0in;  mso-para-margin-right:0in;  mso-para-margin-bottom:10.0pt;  mso-para-margin-left:0in;  line-height:115%;  mso-pagination:widow-orphan;  font-size:11.0pt;  font-family:\"Calibri\",\"sans-serif\";  mso-ascii-font-family:Calibri;  mso-ascii-theme-font:minor-latin;  mso-hansi-font-family:Calibri;  mso-hansi-theme-font:minor-latin;  mso-bidi-font-family:Latha;  mso-bidi-theme-font:minor-bidi;  mso-bidi-language:AR-SA;}  &lt;![endif]-->  </p>\n<div><span lang=\"EN\">There are numbers of blogs that folks wrote about memory leaks in Microsoft .Net Framework managed code and unmanaged code based applications. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This blog,</span><span lang=\"EN\"></span></div>\n<ul type=\"disc\">\n<li><span lang=\"EN\">Show coding practices      that can cause memory leaks which are more unique to WPF-base apps </span><span lang=\"EN\"></span></li>\n<li><span lang=\"EN\">Share information about      memory leaks in the .NET Framework;</span><span lang=\"EN\"> </span></li>\n<li><span lang=\"EN\">Show how to avoid these      leaks </span><span lang=\"EN\"></span></li>\n<li><span lang=\"EN\">Discuss the tools and      techniques available to detect the leaks </span><span lang=\"EN\"></span></li>\n</ul>\n<div><span lang=\"EN\"></span><span lang=\"EN\"></span></div>\n<h2 align=\"center\"><strong><u><span lang=\"EN\">The Sample</span></u></strong><span lang=\"EN\"></span></h2>\n<div><span lang=\"EN\">To illustrate the issues I am showing a sample application. The application can launch different child windows; each can cause a separate memory leak. In each of the cases, closing the child window does not actually release the memory held by Window object as you would expect.</span><span lang=\"EN\"></span></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/f1ad1-1.jpg\"><img border=\"0\" height=\"299\" src=\"https://wpfplayground.files.wordpress.com/2011/10/f1ad1-1.jpg?w=320&amp;h=299\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">For clarity, I&#x2019;ve included a table of the leaks:</span></div>\n<div></div>\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"1\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"395\">\n<div align=\"center\"><b><span>Leak   Description</span></b><span></span></div>\n</td>\n<td valign=\"top\" width=\"112\">\n<div align=\"center\"><strong><span>Developer Error</span></strong><span></span></div>\n</td>\n<td valign=\"top\" width=\"84\">\n<div align=\"center\"><strong><span>NETFX 3.0 </span></strong><span></span></div>\n</td>\n<td valign=\"top\" width=\"92\">\n<div align=\"center\"><strong><span>NETFX 3.5 </span></strong><span></span></div>\n</td>\n<td valign=\"top\" width=\"133\">\n<div align=\"center\"><strong><span>NETFX 3/5 sp1</span></strong><span></span></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"393\">   <span>Improper Use of Event Handlers</span><span></span></td>\n<td valign=\"top\" width=\"113\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"85\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"133\">\n<div align=\"center\"></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"390\">   <span>Improper Use of Data Binding</span><span></span></td>\n<td valign=\"top\" width=\"114\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"86\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"390\">   <span>Improper Use of Command Binding</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"87\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"389\">   <span>Improper Use of Static Event   Handlers</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"88\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"388\">   <span>Use BitmapImage in ImageSource</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"89\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"388\">   <span>Multiple Use of BitmapImage</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"89\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"388\">   <span>Use of downloaded BitmapImage</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"89\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"388\">   <span>CMilChannel leaks if initial HWND   destroyed on XP</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"89\">\n<div align=\"center\"><span>X   (XP only)</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"><span>X   (XP only)</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"><span>X   (XP only)</span><span></span></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"388\">   <span>ShutdownListener leaked for each   thread using Binding</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"89\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"><span>X</span><span></span></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"388\">   <span>Create and Destroy WriteableBitmap   on XP in HW</span><span></span></td>\n<td valign=\"top\" width=\"115\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"89\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"93\">\n<div align=\"center\"></div>\n</td>\n<td valign=\"top\" width=\"132\">\n<div align=\"center\"><span>X   (XP in HW Only)</span><span></span></div>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"388\">   <span>SW Viewport 3D w/ VisualBrush, WB,   etc. leaks on XP</span><span></span></td>\n<td valign=\"top\" width=\"116\"></td>\n<td valign=\"top\" width=\"90\"></td>\n<td valign=\"top\" width=\"94\"></td>\n<td valign=\"top\" width=\"133\">\n<div align=\"center\"><span>X   (XP in HW Only)</span><span></span></div>\n</td>\n</tr>\n</tbody>\n</table>\n<div align=\"center\"></div>\n<div align=\"center\"><strong><u><span lang=\"EN\">The Leak</span></u></strong></div>\n<div align=\"center\"></div>\n<div><span lang=\"EN\">To see the leak:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>1.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">On Windows Vista, launch </span><span lang=\"EN\"><a href=\"http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx\"><span>Process Explorer</span></a></span><span lang=\"EN\">.&#xA0; Open the process property dialog for your app (Right-Click/Properties) </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>2.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Launch few of the Child windows.&#xA0; </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>3.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Notice memory grows by ~50MB on each launch.</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\"><span>4.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Close a dialog without checking the checkbox (e.g. &#x201C;Clear events on Close to avoid memory Leak&#x201D;.)</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\"><span>5.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Click of &#x201C;Force GC&#x201D; to force garbage collection.</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\"><span>6.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Notice memory is not re-claimed </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>7.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Repeat (4)+(5) , but now check each of the Checkbox.&#xA0; This will free the objects being held when window closes. Notice in Process Explorer that memory is now reclaimed.</span><span lang=\"EN\"> </span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/clip_image004_2.jpg\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/4ca34-2.jpg\"><img border=\"0\" height=\"320\" src=\"https://wpfplayground.files.wordpress.com/2011/10/4ca34-2.jpg?w=269&amp;h=320\" width=\"269\"></a></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/clip_image004_2.jpg\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/clip_image004_2.jpg\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Each of the child windows causes a leak because of the reasons below.</span><span lang=\"EN\"> </span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">1. <u>Use of Event Handler</u></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_9.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/e0fdc-3.jpg\"><img border=\"0\" height=\"211\" src=\"https://wpfplayground.files.wordpress.com/2011/10/e0fdc-3.jpg?w=320&amp;h=211\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_9.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Figure 1-Leak caused by use of Event Handler</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Cause:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak is triggered because the child window (Window2) has a reference (it registered to an event) to Window1 TextBox1 which remains alive causing the Window2 object and its element tree to remain alive.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">In general, if you do this:</span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Foo.SomeEvent += new EventHandler(Bar.SomeMethod)&#xA0; </code></pre>\n</div>\n<div><span lang=\"EN\">Then when you done using <i>Bar</i>, but you are still using <i>Foo</i> then <i>Bar</i> will still remain alive as well. Not what you might have expected.</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Code:</span></strong><span lang=\"EN\"></span></div>\n<div>\n<pre><code>Window1.w1.TextBox1.TextChanged += new TextChangedEventHandler(this.TextBox1_TextChanged);</code></pre>\n</div>\n<div><span lang=\"EN\">The Window2 object will remains &#x201C;alive&#x201D; as long as TextBox1 in Windows1 remain alive.</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">The Fix/Workaround:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">There are couple of approaches, the easiest one is simply to un-register the Windows2 object from its various event sources when the windows is about to close.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">e.g.: </span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>Window1.w1.TextBox1.TextChanged -= new TextChangedEventHandler(TextBox1_TextChanged);</code></pre>\n</div>\n<div><span lang=\"EN\">The second approach is to create some sort of indirections (e.g. &#x201C;Weak references&#x201D;). See this </span><span lang=\"EN\"><a href=\"http://blogs.msdn.com/greg_schechter/archive/2004/05/27/143605.aspx\"><span>Greg Schechter&#x2019;s blog</span></a></span><span lang=\"EN\"> for an example.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">2. <u>Use of Data Binding</u></span></b><b><u><span lang=\"EN\"> </span></u></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_15.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/b324a-4.jpg\"><img border=\"0\" height=\"201\" src=\"https://wpfplayground.files.wordpress.com/2011/10/b324a-4.jpg?w=320&amp;h=201\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_15.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Figure 2 &#x2013; Leak caused by use of Data Binding </span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Cause:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak documented in this </span><span lang=\"EN\"><a href=\"http://support.microsoft.com/kb/938416/en-us\"><span>kb article</span></a></span><span lang=\"EN\">. It is triggered because:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">The TextBlock control has a binding to an object (myGrid) that has a reference back to the TextBlock (it is one of myGrid children&#x2019;s).</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Note that this type of a DataBinding leak is unique to a specific scenario (and not to all DataBinding scenarios) as documented in the </span><span lang=\"EN\"><a href=\"http://support.microsoft.com/kb/938416/en-us\"><span>kb article</span></a></span><span lang=\"EN\">.&#xA0; The property in the Path is a not a DependencyProperty and not on a class which implements INotifyPropertyChanged and in addition a chain of strong reverences must exist.</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Code:</span></strong><span lang=\"EN\"></span></div>\n<div>\n<pre><code>myDataBinding = new Binding(&quot;Children.Count&quot;);</code></pre>\n<pre><code>myDataBinding.Source = myGrid; </code></pre>\n<pre><code>myDataBinding.Mode = BindingMode.OneWay;</code></pre>\n<pre><code>MyTextBlock.SetBinding(TextBlock.TextProperty, myDataBinding);</code></pre>\n</div>\n<div><span lang=\"EN\">Same leaky code can be also written in XAML:</span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>&#xA0;&#xA0; &lt;TextBlock Name=&quot;MyTextBlock&quot; Text=&quot;{Binding ElementName=myGrid, Path=Children.Count}&quot; /&gt;</code></pre>\n</div>\n<div><strong><span lang=\"EN\">Fix/Workaround:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">There are few of approaches, the easiest one is simply to clear the binding when the windows is about to close. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">e.g.:</span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; BindingOperations.ClearBinding(MyTextBlock, TextBlock.TextProperty);</code></pre>\n</div>\n<div><span lang=\"EN\">Other approach is to set the mode of the data binding to <b><i>OneTime</i></b>. See the </span><span lang=\"EN\"><a href=\"http://support.microsoft.com/kb/938416/en-us\"><span>kb article</span></a></span><span lang=\"EN\"> for other ideas.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">3. <u>Use of Command Binding</u></span></b><b><u><span lang=\"EN\"> </span></u></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_17.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/97bdf-5.jpg\"><img border=\"0\" height=\"191\" src=\"https://wpfplayground.files.wordpress.com/2011/10/97bdf-5.jpg?w=320&amp;h=191\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_17.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Figure 3 &#x2013; Leak caused by use of Command Binding</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Cause:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak triggered because Window2 object adds a command binding to Window 1. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">WPF Command Binding uses strong reference which causes the Windows2 object child window not be released as long as Windows2 remain alive.</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Code</span></strong><span lang=\"EN\">:</span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>command = new RoutedCommand(&quot;ClearBox&quot;, this.GetType());</code></pre>\n<pre><code>command.InputGestures.Add(new KeyGesture(Key.F5));</code></pre>\n<pre><code>myCmdBinding = new CommandBinding(command, F5CommandExecute);</code></pre>\n<pre><code>Window1.w1.CommandBindings.Add(myCmdBinding); //add binding to Window 1</code></pre>\n</div>\n<div><u><span lang=\"EN\">Note<b>:</b></span></u><b><span lang=\"EN\"> </span></b><span lang=\"EN\">This is likely not a common code practice, but it is provided to demonstrate the idea certain usage of Command Binding can cause leaks.</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Fix/Workaround:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">The easiest approach is simply to clear the CommandBinding when the windows is about to close.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">E.g.:</span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>&#xA0;&#xA0;&#xA0; Window1.w1.CommandBindings.Remove(myCmdBinding); </code></pre>\n</div>\n<div><strong><span lang=\"EN\">4.</span></strong><span lang=\"EN\"> <strong><u><span>Use of Static Event Handler</span></u></strong></span></div>\n<div></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/1e936-6.jpg\"><img border=\"0\" height=\"187\" src=\"https://wpfplayground.files.wordpress.com/2011/10/1e936-6.jpg?w=320&amp;h=187\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Figure 4 &#x2013; Leak caused by use of Command Binding</span><span lang=\"EN\"></span></div>\n<div></div>\n<div><strong><span lang=\"EN\">Cause</span></strong><span lang=\"EN\">:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak is triggered because the child window (Window2) has a reference (it registered to an event) to a Static event. Since object is static, Windows2 object will never get released. </span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Code:</span></strong><span lang=\"EN\"></span></div>\n<div>\n<pre><code>Application.Current.Activated += new EventHandler(App_Activated);</code></pre>\n</div>\n<div><strong><span lang=\"EN\">The Fix/Workaround:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Simply un-register the Windows2 object from the event sources when the windows is about to close.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">e.g.:</span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>&#xA0;&#xA0;&#xA0; Application.Current.Activated -= new EventHandler(App_Activated);</code></pre>\n</div>\n<div><span lang=\"EN\">The second approach is to create You can consider other approaches like (1) from before. </span><span lang=\"EN\"></span></div>\n<div><strong><u><span lang=\"EN\">5.</span></u></strong><u><span lang=\"EN\"> <strong><span>Use </span></strong><b>of BitmapImage in Image Source</b></span></u><b><span lang=\"EN\"> </span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_21.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/b64ff-7.jpg\"><img border=\"0\" height=\"192\" src=\"https://wpfplayground.files.wordpress.com/2011/10/b64ff-7.jpg?w=320&amp;h=192\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_21.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Figure 5 &#x2013; Leak caused by use of BitmapImage as Image Source </span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Cause</span></strong><span lang=\"EN\">:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak is triggered because under the covers WPF keeps a strong reference between the static BitmapImage (bi1) and the Image (m_Image1).</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">BitmapImage (bi1) is declared Static so it is not Garbage Collected when Window2 is closed, since under the covers WPF hooks events on the BitmapImage (for example the DownloadFailed event) it causes the m_Image1 Image to remain alive. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This in turn causes the entire Window2 tree to also remain alive in memory even after you closed it. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak can happen only when you use BitmapImage. It does not appear when you use DrawingImage for example.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This issue is fixed in the next .Net service pack (.Net 3.5 Sp1)</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Code:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">bi1 =<span>&#xA0;&#xA0;&#xA0;&#xA0; </span></span><span lang=\"EN\">//bi1 is static</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>&#xA0; </span></span><span lang=\"EN\">new</span><span lang=\"EN\"> BitmapImage(</span><span lang=\"EN\">new</span><span lang=\"EN\"> Uri(</span><span lang=\"EN\">&#x201C;Bitmap1.bmp&#x201D;</span><span lang=\"EN\">,UriKind.RelativeOrAbsolute));</span></div>\n<div><span lang=\"EN\">//bi1.Freeze() //if you do not Freeze, your app will leak memory</span><span lang=\"EN\"> </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">m_Image1 = </span><span lang=\"EN\">new</span><span lang=\"EN\"> Image();</span></div>\n<div><span lang=\"EN\">m_Image1.Source = bi1;<span>&#xA0; </span></span></div>\n<div><span lang=\"EN\">MyStackPanel.Children.Add(m_Image1); </span></div>\n<div></div>\n<div><strong><span lang=\"EN\">The Fix/Workaround:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Workaround can depends on your sceanrio. One workaround would be to Freeze the BitmapImage. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">WPF does not hook events for objects that are frozen. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This woraround is used if you click on the 2<sup>nd</sup> checkbox above. Another workaround could be to Clone the BitmapImage or not to make it Static.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">In general you should Freeze objects whenever possible to improve the performance of your application and reduces its working set. Read more </span><span lang=\"EN\"><a href=\"http://msdn2.microsoft.com/en-us/library/ms750509.aspx\"><span>here</span></a></span><span lang=\"EN\">.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">E.g.:</span><span lang=\"EN\"></span></div>\n<div>\n<pre><code>bi1.Freeze();</code></pre>\n</div>\n<div><strong><u><span lang=\"EN\">6.</span></u></strong><u><span lang=\"EN\"> <strong><span>Use </span></strong><b>of BitmapImage in Image Source (Multiple Use)</b></span></u><b><span lang=\"EN\"> </span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_23.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/125e2-8.jpg\"><img border=\"0\" height=\"192\" src=\"https://wpfplayground.files.wordpress.com/2011/10/125e2-8.jpg?w=320&amp;h=192\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_23.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Figure 6 &#x2013; Leak caused by use of BitmapImage as Image Source (multiple use)</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Cause</span></strong><span lang=\"EN\">:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak is related to the leak mentioned above.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak is triggered because under the covers WPF keeps a strong reference between the static BitmapImage (bi1) and the Image (m_Image1).</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">When the Image gets assigned a new source (e.g. m_Image1.Source = bi2;), WPF &#x201C;forgot&#x201D; to remove the previous &#x201C;old&#x201D; events it hooked under the covers for bi1. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Again, since bi1 is static and is not Garbage Collected, it forces the Image to remain alive which causes the entire Windw2 to leak. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This issue was introduced in .Net 3.5. It does not exist in .Net 3.0. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">It is fixed in the next .Net service pack (.Net 3.5 Sp1)</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Code:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">static</span><span lang=\"EN\"> BitmapImage bi1 = </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>&#xA0;&#xA0; </span>new</span><span lang=\"EN\"> BitmapImage(</span><span lang=\"EN\">new</span><span lang=\"EN\"> Uri(</span><span lang=\"EN\">&#x201C;Bitmap1.bmp&#x201D;</span><span lang=\"EN\">, UriKind.RelativeOrAbsolute));</span></div>\n<div><span lang=\"EN\">static</span><span lang=\"EN\"> BitmapImage bi2 = </span></div>\n<div><span lang=\"EN\"><span>&#xA0;&#xA0; </span></span><span lang=\"EN\">new</span><span lang=\"EN\"> BitmapImage(</span><span lang=\"EN\">new</span><span lang=\"EN\"> Uri(</span><span lang=\"EN\">&#x201C;Bitmap2.bmp&#x201D;</span><span lang=\"EN\">, UriKind.RelativeOrAbsolute));</span></div>\n<div><span lang=\"EN\">&#x2026;</span></div>\n<div><span lang=\"EN\">if</span><span lang=\"EN\"> (bi2.CanFreeze)<span>&#xA0;&#xA0;&#xA0; </span></span></div>\n<div><span lang=\"EN\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; </span>bi2.Freeze();</span></div>\n<div><span lang=\"EN\">//bi1.Freeze() //even though you are really using bi2 for Image Source, you also need to Freeze bi1 it to avoid leak </span><span lang=\"EN\"><span>&#xA0;</span></span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">m_Image1 = </span><span lang=\"EN\">new</span><span lang=\"EN\"> Image();</span></div>\n<div><span lang=\"EN\">m_Image1.Source = bi1;<span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; </span></span><span lang=\"EN\">// use un-frozen bitmap, which causes the leak</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">m_Image1.Source = bi2;<span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; </span></span><span lang=\"EN\">// use frozen bitmap</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">MyStackPanel.Children.Add(m_Image1);</span></div>\n<div></div>\n<div><strong><span lang=\"EN\">The Fix/Workaround:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">The workaround is simply not use the code above or also Freeze the other BitmapImage e.g.: bi1.Freeze(); </span><span lang=\"EN\"></span></div>\n<div><strong><u><span lang=\"EN\">7. Use </span></u></strong><b><u><span lang=\"EN\">of downloaded BitmapImage in Image Source</span></u></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_25.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/199ca-9.jpg\"><img border=\"0\" height=\"199\" src=\"https://wpfplayground.files.wordpress.com/2011/10/199ca-9.jpg?w=320&amp;h=199\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_25.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Figure 7 &#x2013; Leak caused by use of downloaded BitmapImage as Image Source</span><span lang=\"EN\"></span></div>\n<div><strong><span lang=\"EN\">Cause</span></strong><span lang=\"EN\">:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak is triggered because WPF does not remove internal reference to certain objects (such as LateBoundBitmapDecoder, BitmapFrameDecode, etc) which are used during web download and causes the leak.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This leak only happens when you download an image from the internet. (E.g. it does not appear when you load images from your local machine)</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This issue will get fixed in the next .net service pack (.Net 3.5 Sp1)</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">To see the leak, you can launch above window, close it, and click on the &#x2018;Force GC&#x2019; button to force garbage collection. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">When you run the below commands in WinDbg, you will notice among others the following objects that remain in the heap. These are the objects that cause the leak and hold on to the Image control and the entire tree after you closed the Window2.</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\">.loadby sos mscorwks</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">!DumpHeap -type System.Windows.Media.Imaging</span></div>\n<div></div>\n<div><span lang=\"EN\">53dadf18<span>&#xA0;&#xA0; </span>6<span>&#xA0;&#xA0; </span>72 System.Windows.Media.UniqueEventHelper`1</span></div>\n<div><span lang=\"EN\"><span>&#xA0;&#xA0;&#xA0; </span>[[System.Windows.Media.Imaging.DownloadProgressEventArgs, PresentationCore]]</span></div>\n<div><span lang=\"EN\">53da4374<span>&#xA0;&#xA0; </span>1<span>&#xA0; </span>108 System.Windows.Media.Imaging.PngBitmapDecoder</span></div>\n<div><span lang=\"EN\">53da09e0<span>&#xA0;&#xA0; </span>4<span>&#xA0; </span>112 System.Windows.Media.Imaging.BitmapSourceSafeMILHandle</span></div>\n<div><span lang=\"EN\">53d8d2f0<span>&#xA0;&#xA0; </span>1<span>&#xA0; </span>120 System.Windows.Media.Imaging.LateBoundBitmapDecoder</span></div>\n<div><span lang=\"EN\">53da0524<span>&#xA0;&#xA0; </span>1<span>&#xA0; </span>172 System.Windows.Media.Imaging.BitmapFrameDecode</span></div>\n<div><span lang=\"EN\">53da89c8<span>&#xA0;&#xA0; </span>3<span>&#xA0; </span>648 System.Windows.Media.Imaging.BitmapImage</span></div>\n<div></div>\n<div><strong><span lang=\"EN\">Code:</span></strong><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">// You will see leak when using BitmapImage loaded from the Internet</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">BitmapImage image = </span><span lang=\"EN\">new</span><span lang=\"EN\"> BitmapImage();</span></div>\n<div><span lang=\"EN\">image.BeginInit();</span></div>\n<div><span lang=\"EN\">image.UriSource = </span><span lang=\"EN\">new</span><span lang=\"EN\"> Uri(</span><span lang=\"EN\">@<a href=\"http://www.somesite.com/some_image.png\">http://www.somesite.com/some_image.png</a></span><span lang=\"EN\">,</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; </span><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;</span>UriKind.RelativeOrAbsolute);</span></div>\n<div><span lang=\"EN\">image.CacheOption = BitmapCacheOption.OnLoad;</span></div>\n<div><span lang=\"EN\">image.CreateOptions = BitmapCreateOptions.None;</span></div>\n<div><span lang=\"EN\">image.EndInit();</span></div>\n<div></div>\n<div><span lang=\"EN\">m_Image1 = </span><span lang=\"EN\">new</span><span lang=\"EN\"> Image();</span></div>\n<div><span lang=\"EN\">m_Image1.Source = image;<span>&#xA0;&#xA0; </span></span></div>\n<div><span lang=\"EN\">MyStackPanel.Children.Add(m_Image1);</span></div>\n<div></div>\n<div><b><span lang=\"EN\">The Fix/Workaround:</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">The workaround is to consider downloading the BitmapImage first in other means to a temporary folder or to memory and then use the local BitmapImage . (See </span><span lang=\"EN\"><a href=\"http://msdn2.microsoft.com/en-us/library/system.net.webclient.downloadfile.aspx\"><b><span>WebClient.DownloadFile</span></b></a></span><span lang=\"EN\"> &amp; </span><span lang=\"EN\"><a href=\"http://msdn2.microsoft.com/en-us/library/system.net.webclient.downloaddata.aspx\"><b><span>WebClient.DownloadData</span></b></a></span><span lang=\"EN\"> APIs)</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">8. <u>CMilChannel leaks if initial HWND is destroyed on XP</u></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_ADD9/clip_image001_2.gif\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/bb078-9.jpg\"><img border=\"0\" height=\"199\" src=\"https://wpfplayground.files.wordpress.com/2011/10/bb078-9.jpg?w=320&amp;h=199\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_ADD9/clip_image001_2.gif\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">Cause:</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This is a leak in WPF present in versions of the framework up to and including .NET 3.5 SP1. This occurs because of the way WPF selects which HWND to use to send messages from the render thread to the UI thread. This sample destroys the first HWND created and starts an animation in a new Window. This causes messages sent from the render thread to pile up without being processed, effectively leaking memory.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">The Fix/Workaround:</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">The workaround is to create a new HwndSource first thing in your App class constructor. This MUST be created before any other HWND is created by WPF. Simply by creating this HwndSource, WPF will use this to send messages from the render thread to the UI thread. This assures all messages will be processed, and that none will leak. <br>Note: This issue is rare; only implement the workaround if you&#x2019;re actually hitting this problem.</span><span lang=\"EN\"></span></div>\n<div><b><u><span lang=\"EN\">9. ShutDownListener leaked for every thread created using Binding</span></u></b><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">Cause</span></b><span lang=\"EN\">:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This is a leak in WPF present in versions of the framework up to and including .NET 3.5 SP1. This occurs because an event handler in WPF&#x2019;s data binding engine is hooked but never unhooked whenever binding is used on a new thread. This sample creates a number of new Threads, and for each creates a new Window using data binding.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">The Fix/Workaround:</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">None Available</span><span lang=\"EN\"></span></div>\n<div><b><u><span lang=\"EN\">10. Create and destroy WriteableBitmap on XP in hardware rendering</span></u></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_ADD9/clip_image002_2.gif\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/4902c-0.jpg\"><img border=\"0\" height=\"193\" src=\"https://wpfplayground.files.wordpress.com/2011/10/4902c-0.jpg?w=320&amp;h=193\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_ADD9/clip_image002_2.gif\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">Cause</span></b><span lang=\"EN\">:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This is a leak in WPF present in version 3.5 SP1 ONLY. This occurs whenever a WriteableBitmap is created and destroyed on Windows XP using hardware rendering. This sample repeatedly creates, updates, and displays new WriteableBitmaps continuously to leak memory.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">The Fix/Workaround:</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Force software rendering for the Window containing the WriteableBitmap by setting </span><span lang=\"EN\"><a href=\"http://msdn.microsoft.com/en-us/library/system.windows.interop.hwndtarget.rendermode.aspx\"><b><span>HwndTarget.RenderMode</span></b></a></span><span lang=\"EN\"> to RenderMode.SoftwareOnly. </span><span lang=\"EN\"></span></div>\n<div><b><u><span lang=\"EN\">11. Viewport3D w/ VisualBrush, WriteableBitmap, etc, leaks in Windows XP in SW</span></u></b><span lang=\"EN\"></span></div>\n<div></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/91e3b-11.jpg\"><img border=\"0\" height=\"195\" src=\"https://wpfplayground.files.wordpress.com/2011/10/91e3b-11.jpg?w=320&amp;h=195\" width=\"320\"></a></div>\n<div></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_ADD9/clip_image003_2.gif\"><b><i><span><span>&#xA0;</span></span></i></b></a><span lang=\"EN\"><br></span><b><span lang=\"EN\">Cause:</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This is a leak in WPF present in version 3.5 SP1 ONLY. This occurs when a VisualBrush, WriteableBitmap, or some select other classes are used within a Viewport3D in software rendering mode.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">The Fix/Workaround:</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">If available, use HW rendering. If HW rendering is not available, and you suspect that you&#x2019;re hitting this leak, try replacing your brush with a SolidColorBrush to see if the leak goes away. If the leak persists, you have another leak in your application. If the leak goes away consider using a different brush that does not leak; no other workaround is available.</span><span lang=\"EN\"></span></div>\n<div align=\"center\"><b><u><span lang=\"EN\">Debugging the leak</span></u></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">To experiment with finding the leak I used both </span><span lang=\"EN\"><a href=\"http://www.microsoft.com/downloads/details.aspx?FamilyID=a362781c-3870-43be-8926-862b40aa0cd0&amp;displaylang=en\"><b><span>CLR Profiler for the .NET Framework 2.0 </span></b></a></span><span lang=\"EN\">and </span><span lang=\"EN\"><a href=\"http://www.microsoft.com/whdc/devtools/debugging/installx86.mspx\"><b><span>WinDbg</span></b></a></span><span lang=\"EN\"> and both seem adequate. The advantage is that both are free downloads.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">Useful tips:</span></b><span lang=\"EN\"> </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">I found that:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>1.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">It is much easier to detect a leak if you purposely make it very large. E.g. add 50MB to the size of the objects that you suspect to be leaking.&#xA0; In my example I am allocating ~50MB of memory in each child window (byte[]). </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>2.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">If you only have a small leak it may require many iterations before you can conclude that leak exists when using Process Explorer or Task Manger.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>3.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Forcing Garbage Collector to reclaim memory helps to differentiate between objects that leak and the ones that don&#x2019;t. This code should do it: </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>4.<span>&#xA0; </span></span></span><span lang=\"EN\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;</span>GC.Collect();</span></div>\n<div><span lang=\"EN\"><span>5.<span>&#xA0; </span></span></span><span lang=\"EN\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;</span>GC.WaitForPendingFinalizers();</span></div>\n<div><span lang=\"EN\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; </span>GC.Collect();</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>6.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Forcing the GC is useful when you visually inspect memory (e.g. using Process Explorer), if you use the CLR Profiler it already force GC between each heap snapshot.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">Using CLR Profiler</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>1.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Launch the CLR Memory Profiler as admin on Vista </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>2.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Uncheck &#x201C;Allocations&#x201D;, &#x201C;Calls&#x201D; &amp; &#x201C;Profiling Active&#x201D; checkboxes</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\"><span>3.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Do &#x201C;Start Application&#x201D; and get the app to the point where you ready to take the &#x2018;before&#x2019; heap snapshot. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\"><span>4.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Then click &#x201C;Show Heap Now&#x201D;</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\"><span>5.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Now check the &#x201C;Profiling Active&#x201D; &amp; &#x201C;Allocations&#x201D; to enable profiling. </span></div>\n<div><span lang=\"EN\"><span>6.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Launch&#xA0; and then close the &#x2018;leaky&#x2019; window (e.g. &#x201C;Event Handler test&#x201D;)</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\"><span>7.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Take another &#x201C;Show Heap Now&#x201D;.</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\"><span>8.<span>&#xA0;&#xA0;&#xA0; </span></span></span><span lang=\"EN\">Right-click on the last graph and &#x201C;Show New Objects&#x201D;.</span><span lang=\"EN\"> </span></div>\n<div><span lang=\"EN\">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; </span><b><span><span>&#xA0;</span></span></b></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/77223-12.jpg\"><img border=\"0\" height=\"157\" src=\"https://wpfplayground.files.wordpress.com/2011/10/77223-12.jpg?w=320&amp;h=157\" width=\"320\"></a></div>\n<div></div>\n<div></div>\n<div><span lang=\"EN\">You can see that my TextChangedEventHandler is holding on to 50MB of Byte[], as in image below:</span><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_14.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/ced1b-13.jpg\"><img border=\"0\" height=\"118\" src=\"https://wpfplayground.files.wordpress.com/2011/10/ced1b-13.jpg?w=320&amp;h=118\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_14.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Repeating the process for the &#x201C;Command Binding test&#x201D; window, shows the 50MB of CommandBinding object. See image:</span><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_12.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><a href=\"https://wpfplayground.files.wordpress.com/2011/10/ee4b5-14.jpg\"><img border=\"0\" height=\"109\" src=\"https://wpfplayground.files.wordpress.com/2011/10/ee4b5-14.jpg?w=320&amp;h=109\" width=\"320\"></a></div>\n<div><b><span><span><br></span></span></b><span lang=\"EN\"></span></div>\n<div><a href=\"http://blogs.msdn.com/blogfiles/jgoldb/WindowsLiveWriter/FindingMemoryLeaksinWPFbasedapplications_C681/image_12.png\"><b><span><span><br></span></span></b></a><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">Using WinDBG</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Pretty much followed the directions provided in this blog </span><span lang=\"EN\"><a href=\"http://blogs.msdn.com/ricom/archive/2004/12/10/279612.aspx\"><b><span>here</span></b></a></span><span lang=\"EN\">.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">windbg -p </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0:004&gt; .loadby sos mscorwks</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">I performed:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0:005&gt; !DumpHeap &#x2013;stat</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Twice (before and after the leak) </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">&#x201C;!DumpHeap &#x2013;stat&#x201D; showed this before the leak happened:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">&#x2026;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">5695e56c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 460&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 18400 System.Windows.DependencyProperty</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">5696975c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 188&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 20280 System.Windows.EffectiveValueEntry[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">79135df4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 99&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 34440 System.Reflection.CustomAttributeNamedParameter[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0056ed60&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 297&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 37656&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Free</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">7913b600&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 177&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 65376 System.Collections.Hashtable+bucket[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">7912b884&#xA0;&#xA0;&#xA0;&#xA0; 3307&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 152020 System.Object[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">790fc6cc&#xA0;&#xA0;&#xA0;&#xA0; 8516&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 455296 System.String</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Total 32362 objects</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">After the leak &#x201C;!DumpHeap &#x2013;stat&#x201D; showed this :</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">5543b1e8&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 189&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 11340 System.Windows.Markup.BamlAttributeInfoRecord</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">53d0d3ac&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 40&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 11424 System.Windows.ClassHandlers[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">569698f4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 384&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 11888 MS.Utility.FrugalMapBase+Entry[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">790febbc&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 627&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 12540 System.RuntimeType</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">5695e7c0&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 628&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 12560 System.Windows.DependencyProperty+FromNameKey</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">5696975c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 244&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 15928 System.Windows.EffectiveValueEntry[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">5542d18c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 676&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 16224 System.Windows.FrameworkPropertyMetadata</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">5695e56c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 484&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 19360 System.Windows.DependencyProperty</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">7913b600&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 80&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 38952 System.Collections.Hashtable+bucket[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">7912b884&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 785&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 73608 System.Object[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0056ed60&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 288&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 103380&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Free</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">790fc6cc&#xA0;&#xA0;&#xA0;&#xA0; 7218&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 373856 System.String</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">7913b858&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 57&#xA0;&#xA0;&#xA0;&#xA0; 52433700 System.Byte[]</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">A &#x2018;suspicions&#x2019; allocation of 50MB of byte[] is shown</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">I then performed:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0:005&gt; !dumpheap -type System.Byte[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">&#x2026;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">013894d4 7913b858&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 60&#xA0;&#xA0;&#xA0;&#xA0; </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0138965c 7913b858&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 228&#xA0;&#xA0;&#xA0;&#xA0; </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">013897c0 7913b858&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 60&#xA0;&#xA0;&#xA0;&#xA0; </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">01389a70 7913b858&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 60&#xA0;&#xA0;&#xA0;&#xA0; </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0138f6d4 7913b858&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 500&#xA0;&#xA0;&#xA0;&#xA0; </span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">06dc1000</span></b><span lang=\"EN\"> 7913b858 52428816&#xA0;&#xA0;&#xA0;&#xA0; </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">total 57 objects</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Statistics:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; MT&#xA0;&#xA0;&#xA0; Count&#xA0;&#xA0;&#xA0; TotalSize Class Name</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">7913b858&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 57&#xA0;&#xA0;&#xA0;&#xA0; 52433700 System.Byte[]</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Total 57 objects</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">I then performed gcroot on the largest allocation and windbg reported</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">0:005&gt; !gcroot 06dc1000</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Note: Roots found on stacks may be false positives. Run &#x201C;!help gcroot&#x201D; for</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">more info.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Scan Thread 0 OSTHread 1280</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">ESP:37f2d8:Root:012f6d68(System.Windows.Threading.Dispatcher)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0130c6b0(System.Windows.Input.InputManager)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0130cd58(System.Windows.Input.StylusLogic)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0130ce8c(System.Collections.Generic.Dictionary`2[[System.Object, mscorlib],[System.Windows.Input.PenContexts, PresentationCore]])-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0130ced8(System.Collections.Generic.Dictionary`2+Entry[[System.Object, mscorlib],[System.Windows.Input.PenContexts, PresentationCore]][])-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0135e1e8(System.Windows.Interop.HwndSource)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">012fab4c(TestWpfApp.Window1)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">01334b90(System.Windows.Controls.TextBox)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0136f664(System.Windows.EffectiveValueEntry[])-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0134deb0(System.Windows.EventHandlersStore)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">01383340(MS.Utility.ThreeObjectMap)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">01383320(MS.Utility.FrugalObjectList`1[[System.Windows.RoutedEventHandlerInfo, PresentationCore]])-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0138332c(MS.Utility.SingleItemList`1[[System.Windows.RoutedEventHandlerInfo, PresentationCore]])-&gt;</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">01383300(System.Windows.Controls.TextChangedEventHandler)-&gt;</span></b><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">0137e2d8(TestWpfApp.Window2)-&gt;</span></b><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">06dc1000(System.Byte[])</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">Scan Thread 2 OSTHread 1500</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">DOMAIN(005656C8):HANDLE(WeakSh):c1794:Root:01384aec(System.EventHandler)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">01384828(System.Windows.Documents.AdornerLayer)-&gt;</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">0137e2d8(TestWpfApp.Window2)</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This is pretty much the same info that the CLR memory Profiler reported.</span><span lang=\"EN\"></span></div>\n<div><b><span lang=\"EN\">Other tools</span></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">There are other third-party memory profilers such as </span><span lang=\"EN\"><a href=\"http://memprofiler.com/\"><b><span>SciTech&#x2019;s Memory Profiler</span></b></a></span><span lang=\"EN\"> , </span><span lang=\"EN\"><a href=\"http://www.red-gate.com/products/ants_profiler/index.htm\"><b><span>Red-Gate&#x2019;s ANTS Profiler</span></b></a></span><span lang=\"EN\"> , </span><span lang=\"EN\"><a href=\"http://www.yourkit.com/.net/profiler/index.jsp\"><b><span>YourKit Profiler</span></b></a></span><span lang=\"EN\">, </span><span lang=\"EN\"><a href=\"http://www.jetbrains.com/profiler/\"><b><span>JetBrains dotTrace 3.0</span></b></a></span><span lang=\"EN\"> and others. All provide nice and richer user interface and better support than the tools I used above.</span><span lang=\"EN\"></span></div>\n<div align=\"center\"><b><u><span lang=\"EN\">Other types of leaks</span></u></b><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">There are other types of managed memory leaks but outside the scope of this blog.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">One such typical leak is when a managed object is holding onto unmanaged resources.</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This can occur when:</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">a) Managed objects that hold on to the unmanaged resources and do not clean-up after themselves as they suppose to (typically in the </span><span lang=\"EN\"><a href=\"http://msdn2.microsoft.com/en-us/library/b1yfkh5e%28vs.71%29.aspx\"><b><span>IDisposable implementation</span></b></a></span><span lang=\"EN\">).</span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">b) Very small managed object that holds onto a large amount of unmanaged memory. The garbage collector sees only small amount of managed memory and does not realize that collection is required. This scenario is typically common with bitmaps since bitmaps have a small managed component holding on to a large size of unmanaged memory. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">This scenario is improved in .Net 2.0 with the introduction of the <i><a href=\"http://msdn2.microsoft.com/en-us/library/system.gc.addmemorypressure.aspx\"><b><span>AddMemoryPressure</span></b></a></i> API which allows objects to tell the garbage collector of the unmanaged allocation size. </span><span lang=\"EN\"></span></div>\n<div><span lang=\"EN\">WPF internally already forces garbage collection, so the recommendation to consider using the <i>AddMemoryPressure</i> API is only if you have a similar scenario in your own app.</span><span lang=\"EN\"></span></div>\n<div></div>\n</div>\n\t\t\t"}