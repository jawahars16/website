{"meta":{"featuredImage":"https://s0.wp.com/i/blank.jpg","published_date":"2014-07-28T00:00:00.000Z","postId":"visual-tree-helpers","title":"Visual Tree Helpers","excerpt":"\t\t\tWPF User Interface is represented in a way of tree. There are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree. The Logical tree does not contain the core controls of WPF. For example, the child object of a ","tags":["logical tree","tree system","visual tree","wpf","xaml"]},"content":"\n\t\t\t\t<p>WPF User Interface is&#xA0;represented in a way of tree.&#xA0;There are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree. The Logical tree does not contain the core controls of WPF. For example, the child object of a ContentControl is just represented by Content property. The visual tree includes all the controls that WPF used internally to build the tree system. For example the content of ContentControl is represented by a TextBlock, if the value is string. And again the textblock may composed of a scroll viewer and error adorner, etc.</p>\n<p><span id=\"more-393\"></span></p>\n<p>WPF provides built-in API to traverse the tree, but it is limited. For example if you want to get an element in top of tree by its name or type, you need iterate over the tree by using <a href=\"http://msdn.microsoft.com/en-us/library/system.windows.media.visualtreehelper(v=vs.110).aspx\">VisualTreeHelper </a>class. Below, I have provided some useful extensions that will help to get the&#xA0;parent or child in any application.</p>\n<h2>FindAncestor</h2>\n<h3>Usage</h3>\n<pre><code>Grid rootGrid = submitButton.FindAncestor&lt;Grid&gt;();<br></code></pre>\n<h3>Source</h3>\n<pre><code>        public static T FindAncestor&lt;T&gt;(this DependencyObject element)<br>            where T : DependencyObject<br>        {<br>            // Try get a parent and check for type.<br>            var parent = VisualTreeHelper.GetParent(element);<br>            if (parent is T)<br>            {<br>                return (T)parent;<br>            }<br>            return FindAncestor&lt;T&gt;(parent);<br>        }<br><br></code></pre>\n<h2>FindDescendant</h2>\n<h3>Usage</h3>\n<pre><code>Button submitButton = root.FindDescendant&lt;Button&gt;();<br></code></pre>\n<h3>Usage</h3>\n<pre><code>        public static T FindDescendant&lt;T&gt;(this DependencyObject element)<br>   where T : DependencyObject<br>        {<br>            if (element == null) return null;<br><br>            T foundChild = null;<br><br>            int childrenCount = VisualTreeHelper.GetChildrenCount(element);<br>            // Iterating through all children.<br>            for (int i = 0; i &lt; childrenCount; i++)<br>            {<br>                var child = VisualTreeHelper.GetChild(element, i);<br>                // Check whether child is of that type.<br>                T childType = child as T;<br>                if (childType == null)<br>                {<br>                    // A recursive call since it is null.<br>                    foundChild = FindDescendant&lt;T&gt;(child);<br><br>                    if (foundChild != null) break;<br>                }<br>                else<br>                {<br>                    // Child found<br>                    foundChild = (T)child;<br>                    break;<br>                }<br>            }<br><br>            return foundChild;<br>        }<br><br></code></pre>\n<p><a href=\"https://db.tt/G9TdV1kr\">VisualTreeExtensions.cs</a></p>\n<p>The class has another overload where the method will accept a string parameter for name. It will return the element of that type with that name.</p>\n\t\t\t"}